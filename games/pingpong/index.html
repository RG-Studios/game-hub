<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Ping Pong AI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      background: radial-gradient(#111, #000);
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    let W = window.innerWidth;
    let H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;

    const paddleWidth = 100, paddleHeight = 14;
    let playerX = W / 2 - paddleWidth / 2;
    let aiX = W / 2 - paddleWidth / 2;

    let ball = {
      x: W / 2,
      y: H / 2,
      size: 10,
      vx: 4 * (Math.random() > 0.5 ? 1 : -1),
      vy: 5
    };

    let lives = 3;
    let score = 0;
    let timeStart = Date.now();
    let difficultyMultiplier = 1;
    let gameRunning = true;
    let aiFailedMessageTimer = 0;

    function drawPaddle(x, y) {
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(x, y, paddleWidth, paddleHeight);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
      ctx.fillStyle = "#ffff00";
      ctx.fill();
    }

    function drawUI() {
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      let elapsedTime = Math.floor((Date.now() - timeStart) / 1000);
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Time: " + elapsedTime + "s", 10, 40);
      ctx.fillText("Lives: " + "❤️".repeat(lives), W - 100, 20);
    }

    function resetBall() {
      ball.x = W / 2;
      ball.y = H / 2;
      ball.vx = 4 * (Math.random() > 0.5 ? 1 : -1);
      ball.vy = 5;
      difficultyMultiplier = 1;
    }

    function showAIFailureMessage() {
      aiFailedMessageTimer = 100;
    }

    function drawAIFailureDialog() {
      if (aiFailedMessageTimer > 0) {
        ctx.fillStyle = "#0f0";
        ctx.font = "22px sans-serif";
        ctx.fillText("Great! You just smashed your opponent!", W / 2 - 170, H / 2);
        aiFailedMessageTimer--;
      }
    }

    function gameOver() {
      gameRunning = false;
      ctx.fillStyle = "#f00";
      ctx.font = "24px sans-serif";
      ctx.fillText("Game Over! Final Score: " + score, W / 2 - 120, H / 2);
    }

    function update() {
      if (!gameRunning) return;

      ctx.clearRect(0, 0, W, H);
      let elapsed = (Date.now() - timeStart) / 1000;
      difficultyMultiplier = 1 + elapsed / 30;

      // AI Precision: follow ball perfectly
      aiX = ball.x - paddleWidth / 2;
      aiX = Math.max(0, Math.min(W - paddleWidth, aiX));

      // Ball movement
      ball.x += ball.vx * difficultyMultiplier;
      ball.y += ball.vy * difficultyMultiplier;

      // Wall bounce
      if (ball.x < ball.size || ball.x > W - ball.size) ball.vx *= -1;

      // Player paddle collision
      if (ball.y + ball.size > H - paddleHeight &&
          ball.x > playerX && ball.x < playerX + paddleWidth) {
        ball.vy *= -1;
        score += Math.floor(5 * difficultyMultiplier);
      }

      // AI paddle collision
      if (ball.y - ball.size < paddleHeight &&
          ball.x > aiX && ball.x < aiX + paddleWidth) {
        ball.vy *= -1;
      }

      // If AI fails (ball hits top edge)
      if (ball.y < 0) {
        score += 50;
        showAIFailureMessage();
        resetBall();
      }

      // If player misses (ball hits bottom)
      if (ball.y > H) {
        lives--;
        if (lives <= 0) {
          gameOver();
          return;
        } else {
          resetBall();
        }
      }

      drawPaddle(playerX, H - paddleHeight);
      drawPaddle(aiX, 0);
      drawBall();
      drawUI();
      drawAIFailureDialog();

      requestAnimationFrame(update);
    }

    // Mobile swipe input
    let lastX = null;
    canvas.addEventListener("touchstart", e => {
      lastX = e.touches[0].clientX;
    });

    canvas.addEventListener("touchmove", e => {
      if (lastX != null) {
        let deltaX = e.touches[0].clientX - lastX;
        playerX += deltaX;
        playerX = Math.max(0, Math.min(W - paddleWidth, playerX));
        lastX = e.touches[0].clientX;
      }
    });

    canvas.addEventListener("touchend", () => {
      lastX = null;
    });

    update();
  </script>
</body>
</html>
